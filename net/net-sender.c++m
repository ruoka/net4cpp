module;
#include <sys/socket.h>
#include <netinet/in.h>
#include <cerrno>

export module net:sender;
import :address_info;
import :endpointbuf;
import :endpointstream;
import :posix;
import :socket;
import std;

export namespace net {

oendpointstream distribute(std::string_view group, std::string_view service_or_port, unsigned ttl = 1);

class sender
{
public:
    sender(std::string_view group, std::string_view service_or_port) :
        m_group{group},
        m_service_or_port{service_or_port}
    {}

    oendpointstream distribute()
    {
        return net::distribute(m_group, m_service_or_port);
    }

    const auto& group() const { return m_group; }
    const auto& service_or_port() const { return m_service_or_port; }

private:
    std::string m_group;
    std::string m_service_or_port;
};

oendpointstream distribute(std::string_view group, std::string_view service_or_port, unsigned ttl)
{
    const auto distribution_address = net::address_info{group, service_or_port, SOCK_DGRAM};
    for(const auto& address : distribution_address)
    {
        net::socket s{address.ai_family, address.ai_socktype, address.ai_protocol};
        if(!s) continue;

        auto t2l = ttl;
        if(posix::setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, &t2l, sizeof t2l) < 0) continue;

        if(posix::connect(s, address.ai_addr, address.ai_addrlen) < 0) continue;

        return new endpointbuf<udp_buffer_size>{std::move(s)};
    }

    throw std::system_error{errno, std::system_category(), "distribute failed"};
}

} // namespace net


