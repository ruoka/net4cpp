export module net:ext;
import std;

export namespace ext
{

inline constexpr std::string_view trim_view(std::string_view sv, std::string_view ws = " \f\n\r\t\v") noexcept
{
    const auto first = sv.find_first_not_of(ws);
    if (first == std::string_view::npos)
        return {};
    const auto last = sv.find_last_not_of(ws);
    return sv.substr(first, last - first + 1);
}

template<class Class>
struct lockable : public Class, public std::mutex
{
    using Class::Class;

    lockable() = default;

    lockable(lockable<Class>&& lc) : Class{std::move(lc)}
    {
        if(!lc.try_lock()) std::terminate(); // Do not move locked objects!
        lc.unlock();
    }

    lockable(const lockable&) = delete;
    lockable& operator=(const lockable&) = delete;
};

template<class Lockable>
auto make_lock(Lockable& l)
{
    return std::unique_lock<Lockable>(l);
}

[[deprecated("prefer chrono formatting (e.g. std::format(\"{:%b}\", date)) over ext::month_to_string")]]
inline const std::string& month_to_string(const std::chrono::month& m) noexcept
{
    static const std::string number2month[] = {"", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
    const auto n = static_cast<unsigned>(m);
    return number2month[n];
}

[[deprecated("prefer chrono formatting (e.g. std::format(\"{:%a}\", date)) over ext::weekday_to_string")]]
inline const std::string& weekday_to_string(const std::chrono::weekday& wd) noexcept
{
    static const std::string number2weekday[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
    const auto n = wd.c_encoding();
    return number2weekday[n];
}

template<typename T>
[[deprecated("prefer chrono formatting (e.g. std::format(\"{:%a, %d %b %Y %H:%M:%S GMT}\", floor<seconds>(tp))) over ext::to_rfc1123")]]
auto to_rfc1123(const std::chrono::time_point<T>& current_time) noexcept
{
    const auto midnight = std::chrono::floor<std::chrono::days>(current_time);
    const auto weekday = std::chrono::weekday{midnight};
    const auto date = std::chrono::year_month_day{midnight};
    const auto time = std::chrono::hh_mm_ss{current_time - midnight};
    auto os = std::ostringstream{};
    os << weekday_to_string(weekday)                                     << ", "
       << std::setw(2) << std::setfill('0') << (unsigned)date.day()   << ' '
       << month_to_string(date.month())                               << ' '
       << std::setw(4) << std::setfill('0') << (int)date.year()       << ' '
       << std::setw(2) << std::setfill('0') << time.hours().count()   << ':'
       << std::setw(2) << std::setfill('0') << time.minutes().count() << ':'
       << std::setw(2) << std::setfill('0') << time.seconds().count() << ' '
       << "GMT";
    return os.str();
}

inline auto to_time_point(const std::string_view sv)
{
    int YYYY = 0; unsigned MM = 0u, DD = 0u, hh = 0u, mm = 0u, ss = 0u, fff = 0u;
    auto res = std::from_chars(sv.data(), sv.data() + 4, YYYY);
    res = std::from_chars(++res.ptr, res.ptr + 2, MM);
    res = std::from_chars(++res.ptr, res.ptr + 2, DD);
    if(sv.length() == 24)
    {
        res = std::from_chars(++res.ptr, res.ptr + 2, hh);
        res = std::from_chars(++res.ptr, res.ptr + 2, mm);
        res = std::from_chars(++res.ptr, res.ptr + 2, ss);
        res = std::from_chars(++res.ptr, res.ptr + 3, fff);
    }
    using namespace std::chrono;
    return sys_days{year{YYYY}/month{MM}/day{DD}} + hours{hh} + minutes{mm} + seconds{ss} + milliseconds{fff};
}

inline void ascii_to_upper(std::string& str) noexcept
{
    for (auto& ch : str)
    {
        const auto c = static_cast<unsigned char>(ch);
        if (c >= static_cast<unsigned char>('a') && c <= static_cast<unsigned char>('z'))
            ch = static_cast<char>(c - static_cast<unsigned char>('a' - 'A'));
    }
}

inline void ascii_to_lower(std::string& str) noexcept
{
    for (auto& ch : str)
    {
        const auto c = static_cast<unsigned char>(ch);
        if (c >= static_cast<unsigned char>('A') && c <= static_cast<unsigned char>('Z'))
            ch = static_cast<char>(c + static_cast<unsigned char>('a' - 'A'));
    }
}

// Backwards-compatible aliases (locale-free ASCII).
[[deprecated("use ext::ascii_to_upper")]]
inline void to_upper(std::string& str) noexcept { ascii_to_upper(str); }
[[deprecated("use ext::ascii_to_lower")]]
inline void to_lower(std::string& str) noexcept { ascii_to_lower(str); }

inline std::string& trim_right(std::string& str, const char* ws = " \f\n\r\t\v")
{
    auto pos = str.find_last_not_of(ws);
    if (pos == std::string::npos) str.clear();
    else str.erase(pos + 1);
    return str;
}

inline std::string& trim_left(std::string& str, const char* ws = " \f\n\r\t\v")
{
    auto pos = str.find_first_not_of(ws);
    if (pos != std::string::npos) str.erase(0, pos);
    else str.clear();
    return str;
}

inline std::string& trim(std::string& str, const char* ws = " \f\n\r\t\v")
{
    return trim_left(trim_right(str, ws ), ws);
}

} // namespace ext

