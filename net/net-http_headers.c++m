export module net:http_headers;
import :ext;
import :endpointstream;
import std;

export namespace http
{

class headers
{
public:

    using name = std::string;
    using value = std::string;

    bool contains(const name& n) const { return m_values.contains(n); }

    const value& operator[](const name& n) const { return m_values.at(n); }
    
    value& operator[](const name& n) { return m_values[n]; }
    
    void set(const name& n, const value& v)
    {
        auto lower_name = n;
        ext::to_lower(lower_name);
        m_values[lower_name] = v;
    }

    friend std::istream& operator >> (std::istream&, headers&);
    friend std::ostream& operator << (std::ostream&, const headers&);

private:

    std::map<name,value> m_values;
};

inline std::istream& operator >> (std::istream &is,  headers &hdrs)
{
    while(is.good() and is.peek() != '\r' and is.peek() != '\n')
    {
        std::string line;
        if (!std::getline(is, line) || line == "\r" || line.empty()) break;
        
        auto sv = std::string_view{line};
        auto pos = sv.find(':');
        if (pos != std::string_view::npos) {
            const auto name_sv = ext::trim_view(sv.substr(0, pos));
            const auto value_sv = ext::trim_view(sv.substr(pos + 1));

            auto name = std::string{name_sv};
            ext::to_lower(name);
            hdrs.m_values[std::move(name)] = std::string{value_sv};
        }
    }
    return is;
}

inline std::ostream& operator << (std::ostream &os, const headers &hdrs)
{
    for(const auto &[name,value] : hdrs.m_values)
        os << name << ": " << value << net::crlf;
    return os;
}

} // namespace http

