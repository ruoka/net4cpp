export module net:address_info;

import :posix;
import std;

namespace gsl {
    template<typename T> using owner = T;
}

export namespace net {

// Define the iterator FIRST — this makes it complete when address_info uses it
class addrinfo_iterator {
public:
    addrinfo_iterator(posix::addrinfo* a) : m_current{a} {}
    posix::addrinfo& operator*() { return *m_current; }
    addrinfo_iterator& operator++() { m_current = m_current->ai_next; return *this; }
    bool operator!=(const addrinfo_iterator& i) const { return m_current != i.m_current; }
private:
    posix::addrinfo* m_current;
};

// Now define address_info — it can freely use addrinfo_iterator
class address_info {
public:
    address_info(std::string_view node,
                 std::string_view service_or_port,
                 int socktype,
                 int flags = posix::ai_all,
                 int family = posix::af_unspec)
        : m_addrinfo{nullptr}
    {
        using namespace std::literals;

        auto hints = posix::addrinfo{};
        hints.ai_flags = flags;
        hints.ai_family = family;
        hints.ai_socktype = socktype;

        const auto is_any = node.empty() || node == "0.0.0.0" || node == "::";
        const auto node_str = std::string{node};
        const auto service_str = std::string{service_or_port};

        if (!service_str.empty() && std::isdigit(static_cast<unsigned char>(service_str[0]))) {
            hints.ai_flags |= posix::ai_numericserv;
        }
        if (!is_any && !node_str.empty() && std::isdigit(static_cast<unsigned char>(node_str[0]))) {
            hints.ai_flags |= posix::ai_numericnode;
        }

        const auto error = posix::getaddrinfo(
            is_any ? nullptr : node_str.c_str(),
            service_str.empty() ? nullptr : service_str.c_str(),
            &hints,
            &m_addrinfo
        );

        if (error) {
            throw std::runtime_error{
                "address resolution failed for "s +
                (node.empty() ? "ANY"s : std::string{node}) +
                ":" + std::string{service_or_port} +
                " -> " + posix::gai_strerror(error)
            };
        }
    }

    address_info(address_info&& ai) noexcept
        : m_addrinfo{ai.m_addrinfo}
    {
        ai.m_addrinfo = nullptr;
    }

    // Properly implemented move assignment (fixes potential bugs)
    address_info& operator=(address_info&& ai) noexcept {
        if (this != &ai) {
            if (m_addrinfo) posix::freeaddrinfo(m_addrinfo);
            m_addrinfo = ai.m_addrinfo;
            ai.m_addrinfo = nullptr;
        }
        return *this;
    }

    ~address_info() {
        if (m_addrinfo) posix::freeaddrinfo(m_addrinfo);
    }

    explicit operator bool() const { return m_addrinfo != nullptr; }
    const posix::addrinfo* operator->() const { return m_addrinfo; }

    // Now fully valid — addrinfo_iterator is already fully defined
    friend addrinfo_iterator begin(const address_info& a) { return addrinfo_iterator{a.m_addrinfo}; }
    friend addrinfo_iterator end(const address_info&)     { return addrinfo_iterator{nullptr}; }

private:
    address_info(const address_info&) = delete;
    address_info& operator=(const address_info&) = delete;

    gsl::owner<posix::addrinfo*> m_addrinfo;
};

} // namespace net