export module net:address_info;
import :posix;
import std;

namespace gsl {
template<typename T> using owner = T;
}

export namespace net {

class addrinfo_iterator
{
public:
    addrinfo_iterator(posix::addrinfo* a) : m_current{a} {}
    posix::addrinfo& operator*() { return *m_current; }
    addrinfo_iterator& operator++() { m_current = m_current->ai_next; return *this; }
    bool operator!=(const addrinfo_iterator& i) const { return m_current != i.m_current; }
private:
    posix::addrinfo* m_current;
};

class address_info
{
public:
    address_info(std::string_view node, std::string_view service_or_port, int socktype, int flags = posix::ai_all, int family = posix::af_unspec) : m_addrinfo{nullptr}
    {
        using namespace std::literals;
        auto hints = posix::addrinfo{};
        hints.ai_flags = flags;
        hints.ai_family = family;
        hints.ai_socktype = socktype;

        // "0.0.0.0" or empty string means "bind to all interfaces" (INADDR_ANY)
        const auto is_any = node.empty() or node == "0.0.0.0" or node == "::";
        
        const auto node_str = std::string{node};
        const auto service_str = std::string{service_or_port};

        // On macOS, numeric ports require AI_NUMERICSERV to avoid EAI_NONAME
        if (not service_str.empty() and std::isdigit(static_cast<unsigned char>(service_str[0])))
            hints.ai_flags |= posix::ai_numericserv;

        // If we have a numeric host and not "any", use AI_NUMERICHOST
        if (not is_any and not node_str.empty() and std::isdigit(static_cast<unsigned char>(node_str[0])))
            hints.ai_flags |= posix::ai_numericnode;
        
        const auto error = posix::getaddrinfo(is_any ? nullptr : node_str.c_str(), 
                                              service_str.empty() ? nullptr : service_str.c_str(), 
                                              &hints, &m_addrinfo);
        if(error) throw std::runtime_error{"address resolution failed for "s + (node.empty() ? "ANY"s : std::string{node}) + ":" + std::string{service_or_port} + " -> " + posix::gai_strerror(error)};
    }

    address_info(address_info&& ai) noexcept : m_addrinfo{ai.m_addrinfo} { ai.m_addrinfo = nullptr; }

    ~address_info() { if(m_addrinfo) posix::freeaddrinfo(m_addrinfo); }

    explicit operator bool() const { return m_addrinfo != nullptr; }
    const posix::addrinfo* operator->() const { return m_addrinfo; }

    friend addrinfo_iterator begin(const address_info& a) { return addrinfo_iterator{a.m_addrinfo}; }
    friend addrinfo_iterator end(const address_info&) { return addrinfo_iterator{nullptr}; }

private:
    address_info(const address_info&) = delete;
    address_info& operator=(const address_info&) = delete;
    address_info& operator=(address_info&&) = delete;
    gsl::owner<posix::addrinfo*> m_addrinfo;
};

} // namespace net
