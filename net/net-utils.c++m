export module net:utils;
import std;

export namespace utils
{

inline constexpr std::string_view trim_view(std::string_view sv, std::string_view ws = " \f\n\r\t\v") noexcept
{
    const auto first = sv.find_first_not_of(ws);
    if (first == std::string_view::npos)
        return {};
    const auto last = sv.find_last_not_of(ws);
    return sv.substr(first, last - first + 1);
}

template<class Class>
struct lockable : public Class, public std::mutex
{
    using Class::Class;

    lockable() = default;

    lockable(lockable<Class>&& lc) : Class{std::move(lc)}
    {
        if(!lc.try_lock()) std::terminate(); // Do not move locked objects!
        lc.unlock();
    }

    lockable(const lockable&) = delete;
    lockable& operator=(const lockable&) = delete;
};

template<class Lockable>
auto make_lock(Lockable& l)
{
    return std::unique_lock<Lockable>(l);
}

[[deprecated("prefer chrono formatting (e.g. std::format(\"{:%b}\", date)) over utils::month_to_string")]]
inline const std::string& month_to_string(const std::chrono::month& m) noexcept
{
    static const std::string number2month[] = {"", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
    const auto n = static_cast<unsigned>(m);
    return number2month[n];
}

[[deprecated("prefer chrono formatting (e.g. std::format(\"{:%a}\", date)) over utils::weekday_to_string")]]
inline const std::string& weekday_to_string(const std::chrono::weekday& wd) noexcept
{
    static const std::string number2weekday[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
    const auto n = wd.c_encoding();
    return number2weekday[n];
}

inline constexpr std::string_view month_abbrev_view(const std::chrono::month& m) noexcept
{
    // clang (esp. with modules + debug info) can be sensitive to complex local constexpr objects.
    // Keep the lookup table at namespace scope.
    static constexpr std::string_view number2month[] = {"", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
    const auto n = static_cast<unsigned>(m);
    return number2month[n];
}

inline constexpr std::string_view weekday_abbrev_view(const std::chrono::weekday& wd) noexcept
{
    static constexpr std::string_view number2weekday[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
    const auto n = wd.c_encoding();
    return number2weekday[n];
}

template<typename T>
auto rfc1123_legacy(const std::chrono::time_point<T>& current_time) noexcept
{
    const auto midnight = std::chrono::floor<std::chrono::days>(current_time);
    const auto weekday = std::chrono::weekday{midnight};
    const auto date = std::chrono::year_month_day{midnight};
    const auto time = std::chrono::hh_mm_ss{current_time - midnight};
    auto os = std::ostringstream{};
    os << weekday_abbrev_view(weekday)                                   << ", "
       << std::setw(2) << std::setfill('0') << (unsigned)date.day()   << ' '
       << month_abbrev_view(date.month())                              << ' '
       << std::setw(4) << std::setfill('0') << (int)date.year()       << ' '
       << std::setw(2) << std::setfill('0') << time.hours().count()   << ':'
       << std::setw(2) << std::setfill('0') << time.minutes().count() << ':'
       << std::setw(2) << std::setfill('0') << time.seconds().count() << ' '
       << "GMT";
    return os.str();
}

// Parse RFC 1123 HTTP date format: "Tue, 31 Dec 2099 23:59:59 GMT"
inline auto parse_rfc1123_date(std::string_view sv)
{
    using namespace std::chrono;
    
    // Skip weekday (e.g., "Tue, ")
    auto pos = sv.find(',');
    if(pos == std::string_view::npos || pos + 2 >= sv.size())
        throw std::invalid_argument{"Invalid RFC 1123 date format"};
    sv.remove_prefix(pos + 2); // Skip ", "
    
    // Parse day (1-31)
    auto day_end = sv.find(' ');
    if(day_end == std::string_view::npos)
        throw std::invalid_argument{"Invalid RFC 1123 date format"};
    unsigned DD = 0u;
    auto res = std::from_chars(sv.data(), sv.data() + day_end, DD);
    if(res.ec != std::errc{})
        throw std::invalid_argument{"Invalid day in RFC 1123 date"};
    sv.remove_prefix(day_end + 1);
    
    // Parse month abbreviation (Jan, Feb, etc.)
    auto month_end = sv.find(' ');
    if(month_end == std::string_view::npos || month_end != 3)
        throw std::invalid_argument{"Invalid RFC 1123 date format"};
    auto month_str = sv.substr(0, 3);
    unsigned MM = 0u;
    if(month_str == "Jan") MM = 1;
    else if(month_str == "Feb") MM = 2;
    else if(month_str == "Mar") MM = 3;
    else if(month_str == "Apr") MM = 4;
    else if(month_str == "May") MM = 5;
    else if(month_str == "Jun") MM = 6;
    else if(month_str == "Jul") MM = 7;
    else if(month_str == "Aug") MM = 8;
    else if(month_str == "Sep") MM = 9;
    else if(month_str == "Oct") MM = 10;
    else if(month_str == "Nov") MM = 11;
    else if(month_str == "Dec") MM = 12;
    else throw std::invalid_argument{"Invalid month in RFC 1123 date"};
    sv.remove_prefix(4);
    
    // Parse year (4 digits)
    auto year_end = sv.find(' ');
    if(year_end == std::string_view::npos || year_end != 4)
        throw std::invalid_argument{"Invalid RFC 1123 date format"};
    int YYYY = 0;
    res = std::from_chars(sv.data(), sv.data() + 4, YYYY);
    if(res.ec != std::errc{})
        throw std::invalid_argument{"Invalid year in RFC 1123 date"};
    sv.remove_prefix(5);
    
    // Parse time (HH:MM:SS)
    unsigned hh = 0u, mm = 0u, ss = 0u;
    res = std::from_chars(sv.data(), sv.data() + 2, hh);
    if(res.ec != std::errc{} || sv[2] != ':')
        throw std::invalid_argument{"Invalid time in RFC 1123 date"};
    res = std::from_chars(sv.data() + 3, sv.data() + 5, mm);
    if(res.ec != std::errc{} || sv[5] != ':')
        throw std::invalid_argument{"Invalid time in RFC 1123 date"};
    res = std::from_chars(sv.data() + 6, sv.data() + 8, ss);
    if(res.ec != std::errc{})
        throw std::invalid_argument{"Invalid time in RFC 1123 date"};
    
    return sys_days{year{YYYY}/month{MM}/day{DD}} + hours{hh} + minutes{mm} + seconds{ss};
}

inline auto to_time_point(const std::string_view sv)
{
    int YYYY = 0; unsigned MM = 0u, DD = 0u, hh = 0u, mm = 0u, ss = 0u, fff = 0u;
    auto res = std::from_chars(sv.data(), sv.data() + 4, YYYY);
    res = std::from_chars(++res.ptr, res.ptr + 2, MM);
    res = std::from_chars(++res.ptr, res.ptr + 2, DD);
    if(sv.length() == 24)
    {
        res = std::from_chars(++res.ptr, res.ptr + 2, hh);
        res = std::from_chars(++res.ptr, res.ptr + 2, mm);
        res = std::from_chars(++res.ptr, res.ptr + 2, ss);
        res = std::from_chars(++res.ptr, res.ptr + 3, fff);
    }
    using namespace std::chrono;
    return sys_days{year{YYYY}/month{MM}/day{DD}} + hours{hh} + minutes{mm} + seconds{ss} + milliseconds{fff};
}

inline void ascii_to_upper(std::string& str) noexcept
{
    for (auto& ch : str)
    {
        const auto c = static_cast<unsigned char>(ch);
        if (c >= static_cast<unsigned char>('a') && c <= static_cast<unsigned char>('z'))
            ch = static_cast<char>(c - static_cast<unsigned char>('a' - 'A'));
    }
}

inline void ascii_to_lower(std::string& str) noexcept
{
    for (auto& ch : str)
    {
        const auto c = static_cast<unsigned char>(ch);
        if (c >= static_cast<unsigned char>('A') && c <= static_cast<unsigned char>('Z'))
            ch = static_cast<char>(c + static_cast<unsigned char>('a' - 'A'));
    }
}

// Backwards-compatible aliases (locale-free ASCII).
[[deprecated("use utils::ascii_to_upper")]]
inline void to_upper(std::string& str) noexcept { ascii_to_upper(str); }
[[deprecated("use utils::ascii_to_lower")]]
inline void to_lower(std::string& str) noexcept { ascii_to_lower(str); }

inline std::string& trim_right(std::string& str, const char* ws = " \f\n\r\t\v")
{
    auto pos = str.find_last_not_of(ws);
    if (pos == std::string::npos) str.clear();
    else str.erase(pos + 1);
    return str;
}

inline std::string& trim_left(std::string& str, const char* ws = " \f\n\r\t\v")
{
    auto pos = str.find_first_not_of(ws);
    if (pos != std::string::npos) str.erase(0, pos);
    else str.clear();
    return str;
}

inline std::string& trim(std::string& str, const char* ws = " \f\n\r\t\v")
{
    return trim_left(trim_right(str, ws ), ws);
}

// Safe string-to-long-long conversion using std::from_chars
// Throws std::invalid_argument if the string is not a valid number or is out of range
inline auto stoll(std::string_view sv)
{
    auto ll = 0ll;
    auto [ptr, ec] = std::from_chars(sv.begin(), sv.end(), ll);
    if(ec == std::errc::result_out_of_range)
        throw std::invalid_argument{std::string{"Number out of range: "} + std::string{sv}};
    if(ec != std::errc() || ptr != sv.end())
        throw std::invalid_argument{std::string{"Invalid number format: "} + std::string{sv}};
    return ll;
}

// String trimming utilities for string_view
constexpr auto trim_start(std::string_view sv)
{
    auto start = sv.find_first_not_of(" \t\n\r");
    return start == std::string_view::npos ? std::string_view{} : sv.substr(start);
}

constexpr auto trim_end(std::string_view sv)
{
    auto end = sv.find_last_not_of(" \t\n\r");
    return end == std::string_view::npos ? std::string_view{} : sv.substr(0, end + 1);
}

constexpr auto trim(std::string_view sv)
{
    return trim_start(trim_end(sv));
}

inline auto trim_end_to_string(std::string_view sv)
{
    return std::string{trim_end(sv)};
}

inline auto trim_start_to_string(std::string_view sv)
{
    return std::string{trim_start(sv)};
}


} // namespace utils

