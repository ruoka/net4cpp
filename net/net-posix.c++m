module;

#include <netdb.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <cerrno>

export module net:posix;

import std;  // Provides <chrono>, <concepts>, <cstdint>, etc. (and <bit> via libc++ std.cppm on your setup)

#ifndef IPV6_ADD_MEMBERSHIP
#define IPV6_ADD_MEMBERSHIP IPV6_JOIN_GROUP
#endif
#ifndef IPV6_DROP_MEMBERSHIP
#define IPV6_DROP_MEMBERSHIP IPV6_LEAVE_GROUP
#endif
#ifndef MSG_NOSIGNAL
# define MSG_NOSIGNAL 0
#endif

export namespace net::posix {

using ::getsockopt;
using ::setsockopt;
using ::getsockname;
using ::bind;
using ::listen;
using ::select;
using ::accept;
using ::connect;
using ::getnameinfo;
using ::read;
using ::write;
using ::recv;
using ::send;
using ::close;
using ::fcntl;
using ::socket;
using ::inet_pton;
using ::inet_ntop;
using ::getaddrinfo;
using ::freeaddrinfo;
using ::gai_strerror;
using ::gethostname;
using ::getpid;

// Clean up any potential macro pollution from system headers
#undef ntohs
#undef ntohl
#undef ntohll
#undef htons
#undef htonl
#undef htonll

// Generic host â†” network byte order conversion (C++23, constexpr, zero-overhead)
template<std::unsigned_integral T>
inline constexpr T hton(T host) noexcept {
    if constexpr (std::endian::native == std::endian::little) {
        return std::byteswap(host);
    } else {
        return host;
    }
}

template<std::unsigned_integral T>
inline constexpr T ntoh(T net) noexcept {
    return hton(net);
}

// Traditional named aliases for compatibility and readability
inline constexpr uint16_t htons(uint16_t host) noexcept { return hton(host); }
inline constexpr uint32_t htonl(uint32_t host) noexcept { return hton(host); }
inline constexpr uint64_t htonll(uint64_t host) noexcept { return hton(host); }

inline constexpr uint16_t ntohs(uint16_t net) noexcept { return ntoh(net); }
inline constexpr uint32_t ntohl(uint32_t net) noexcept { return ntoh(net); }
inline constexpr uint64_t ntohll(uint64_t net) noexcept { return ntoh(net); }

// Type aliases (clean, consistent naming)
using timeval         = ::timeval;
using fd_set          = ::fd_set;
using addrinfo        = ::addrinfo;
using sockaddr        = ::sockaddr;
using sockaddr_storage = ::sockaddr_storage;
using sockaddr_in     = ::sockaddr_in;
using sockaddr_in6    = ::sockaddr_in6;
using ip_mreq         = ::ip_mreq;
using ipv6_mreq       = ::ipv6_mreq;
using socklen_t       = ::socklen_t;

// fd_set wrappers (safe, noexcept)
inline void fd_zero(fd_set* set) noexcept { FD_ZERO(set); }
inline void fd_set_bit(int fd, fd_set* set) noexcept { FD_SET(fd, set); }
inline bool fd_isset(int fd, const fd_set* set) noexcept { return FD_ISSET(fd, set); }

// Common constants
constexpr auto af_inet          = AF_INET;
constexpr auto af_inet6         = AF_INET6;
constexpr auto af_unspec        = AF_UNSPEC;

constexpr auto sock_stream      = SOCK_STREAM;
constexpr auto sock_dgram       = SOCK_DGRAM;

constexpr auto inaddr_any       = INADDR_ANY;
constexpr auto inaddr_loopback  = INADDR_LOOPBACK;

constexpr auto sol_socket       = SOL_SOCKET;
constexpr auto so_error         = SO_ERROR;
constexpr auto so_reuseaddr     = SO_REUSEADDR;

#ifdef SO_REUSEPORT
constexpr auto so_reuseport = SO_REUSEPORT;
#else
constexpr auto so_reuseport = 0;
#endif

#ifdef SO_NOSIGPIPE
constexpr auto so_nosigpipe = SO_NOSIGPIPE;
#else
constexpr auto so_nosigpipe = 0;
#endif

constexpr auto somaxconn        = SOMAXCONN;

constexpr auto shutdown_rd      = SHUT_RD;
constexpr auto shutdown_wr      = SHUT_WR;
constexpr auto shutdown_rdwr    = SHUT_RDWR;

[[maybe_unused]] constexpr auto ipproto_ip   = IPPROTO_IP;
[[maybe_unused]] constexpr auto ipproto_ipv6 = IPPROTO_IPV6;

constexpr auto ip_multicast_loop     = IP_MULTICAST_LOOP;
constexpr auto ip_multicast_ttl       = IP_MULTICAST_TTL;
constexpr auto ip_add_membership     = IP_ADD_MEMBERSHIP;
constexpr auto ip_drop_membership    = IP_DROP_MEMBERSHIP;
constexpr auto ipv6_add_membership   = IPV6_ADD_MEMBERSHIP;
constexpr auto ipv6_drop_membership  = IPV6_DROP_MEMBERSHIP;

constexpr auto ai_passive       = AI_PASSIVE;
constexpr auto ai_numericnode   = AI_NUMERICHOST;
constexpr auto ai_numericserv   = AI_NUMERICSERV;

#ifdef AI_ALL
constexpr auto ai_all = AI_ALL;
#else
constexpr auto ai_all = 0;
#endif

#ifdef AI_ADDRCONFIG
constexpr auto ai_addrconfig = AI_ADDRCONFIG;
#else
constexpr auto ai_addrconfig = 0;
#endif

#ifdef AI_V4MAPPED
constexpr auto ai_v4mapped = AI_V4MAPPED;
#else
constexpr auto ai_v4mapped = 0;
#endif

constexpr auto ni_numerichost   = NI_NUMERICHOST;
constexpr auto ni_numericserv   = NI_NUMERICSERV;
constexpr auto ni_maxhost       = NI_MAXHOST;
constexpr auto ni_maxserv       = NI_MAXSERV;

constexpr auto msg_nosignal     = MSG_NOSIGNAL;

// Common errno values
constexpr auto econnrefused     = ECONNREFUSED;
constexpr auto etimedout        = ETIMEDOUT;
constexpr auto einprogress      = EINPROGRESS;
constexpr auto ewouldblock      = EWOULDBLOCK;
#ifdef EAGAIN
constexpr auto eagain           = EAGAIN;
#else
constexpr auto eagain           = EWOULDBLOCK; // EAGAIN and EWOULDBLOCK are often the same
#endif
constexpr auto eintr            = EINTR;

inline int get_errno() noexcept { return errno; }

// Improved connect with timeout
int connect_with_timeout(int fd, const sockaddr* address, socklen_t address_len,
                         const std::chrono::milliseconds& timeout)
{
    const auto saved_flags = ::fcntl(fd, F_GETFL, 0);
    if (saved_flags < 0) return -1;

    if (::fcntl(fd, F_SETFL, saved_flags | O_NONBLOCK) < 0) return -1;

    const auto connect_result = ::connect(fd, address, address_len);
    const auto connect_errno  = errno;

    // Restore flags early
    if (::fcntl(fd, F_SETFL, saved_flags) < 0) return -1;

    if (connect_result == 0) return 0;  // Immediate success
    if (connect_errno != EINPROGRESS) return -1;

    fd_set readfds{};
    fd_set writefds{};
    fd_zero(&readfds);
    fd_zero(&writefds);
    fd_set_bit(fd, &readfds);
    fd_set_bit(fd, &writefds);

    timeval tv{};
    timeval* tv_ptr = nullptr;

    if (timeout.count() > 0) {
        tv.tv_sec  = static_cast<decltype(tv.tv_sec)>(timeout.count() / 1000);
        tv.tv_usec = static_cast<decltype(tv.tv_usec)>((timeout.count() % 1000) * 1000);
        tv_ptr = &tv;
    }

    const auto sel = ::select(fd + 1, &readfds, &writefds, nullptr, tv_ptr);
    if (sel <= 0) {
        errno = (sel == 0) ? ETIMEDOUT : errno;
        return -1;
    }

    if (!fd_isset(fd, &writefds)) {
        errno = ETIMEDOUT;
        return -1;
    }

    int optval = 0;
    socklen_t optlen = sizeof(optval);
    if (::getsockopt(fd, SOL_SOCKET, SO_ERROR, &optval, &optlen) < 0) return -1;
    if (optval != 0) {
        errno = optval;
        return -1;
    }

    return 0;
}

} // export namespace net::posix