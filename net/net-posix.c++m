module;
#include <netdb.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <cerrno>

export module net:posix;
import std;

#ifndef IPV6_ADD_MEMBERSHIP
#define IPV6_ADD_MEMBERSHIP IPV6_JOIN_GROUP
#endif

#ifndef IPV6_DROP_MEMBERSHIP
#define IPV6_DROP_MEMBERSHIP IPV6_LEAVE_GROUP
#endif

#ifndef MSG_NOSIGNAL
# define MSG_NOSIGNAL 0
#endif

export namespace net::posix {

using ::getsockopt;
using ::setsockopt;
using ::getsockname;
using ::bind;
using ::listen;
using ::select;
using ::accept;
using ::connect;
using ::getnameinfo;
using ::read;
using ::write;
using ::close;
using ::fcntl;
using ::socket;

// Network byte order conversion functions - portable implementation
// These convert between host byte order and network byte order (big-endian)

#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    // Little-endian system: need to swap bytes
    inline std::uint16_t (htons)(std::uint16_t x) { return __builtin_bswap16(x); }
    inline std::uint32_t (htonl)(std::uint32_t x) { return __builtin_bswap32(x); }
    inline std::uint16_t (ntohs)(std::uint16_t x) { return __builtin_bswap16(x); }
    inline std::uint32_t (ntohl)(std::uint32_t x) { return __builtin_bswap32(x); }
#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
    // Big-endian system: no swapping needed
    inline std::uint16_t (htons)(std::uint16_t x) { return x; }
    inline std::uint32_t (htonl)(std::uint32_t x) { return x; }
    inline std::uint16_t (ntohs)(std::uint16_t x) { return x; }
    inline std::uint32_t (ntohl)(std::uint32_t x) { return x; }
#else
    // Fallback: use compiler-specific byte swap functions
    inline std::uint16_t (htons)(std::uint16_t x) {
        #if defined(_MSC_VER)
            return _byteswap_ushort(x);
        #else
            return __builtin_bswap16(x);
        #endif
    }
    inline std::uint32_t (htonl)(std::uint32_t x) {
        #if defined(_MSC_VER)
            return _byteswap_ulong(x);
        #else
            return __builtin_bswap32(x);
        #endif
    }
    inline std::uint16_t (ntohs)(std::uint16_t x) { return (htons)(x); }
    inline std::uint32_t (ntohl)(std::uint32_t x) { return (htonl)(x); }
#endif

using ::inet_pton;
using ::inet_ntop;

using timeval = ::timeval;
using fd_set = ::fd_set;
using addrinfo = ::addrinfo;
using sockaddr_storage = ::sockaddr_storage;
using sockaddr = ::sockaddr;
using sockaddr_in = ::sockaddr_in;
using sockaddr_in6 = ::sockaddr_in6;
using ip_mreq = ::ip_mreq;
using ipv6_mreq = ::ipv6_mreq;
using socklen_t = ::socklen_t;

inline void fd_zero(fd_set* set) { FD_ZERO(set); }
inline void fd_set_bit(int fd, fd_set* set) { FD_SET(fd, set); }
inline bool fd_isset(int fd, fd_set* set) { return FD_ISSET(fd, set); }

constexpr auto af_inet = AF_INET;
constexpr auto af_inet6 = AF_INET6;
constexpr auto af_unspec = AF_UNSPEC;
constexpr auto sock_stream = SOCK_STREAM;
constexpr auto sock_dgram = SOCK_DGRAM;
constexpr auto inaddr_any = INADDR_ANY;
constexpr auto inaddr_loopback = INADDR_LOOPBACK;
constexpr auto sol_socket = SOL_SOCKET;
constexpr auto so_error = SO_ERROR;
constexpr auto so_reuseaddr = SO_REUSEADDR;
#ifdef SO_REUSEPORT
constexpr auto so_reuseport = SO_REUSEPORT;
#else
constexpr auto so_reuseport = 0;
#endif
#ifdef SO_NOSIGPIPE
constexpr auto so_nosigpipe = SO_NOSIGPIPE;
#else
constexpr auto so_nosigpipe = 0;
#endif

[[maybe_unused]] constexpr auto ipproto_ip = IPPROTO_IP;
[[maybe_unused]] constexpr auto ipproto_ipv6 = IPPROTO_IPV6;

constexpr auto ip_multicast_loop = IP_MULTICAST_LOOP;
constexpr auto ip_multicast_ttl = IP_MULTICAST_TTL;
constexpr auto ip_add_membership = IP_ADD_MEMBERSHIP;
constexpr auto ip_drop_membership = IP_DROP_MEMBERSHIP;

constexpr auto ipv6_add_membership = IPV6_ADD_MEMBERSHIP;
constexpr auto ipv6_drop_membership = IPV6_DROP_MEMBERSHIP;

constexpr auto ai_passive = AI_PASSIVE;
constexpr auto ai_numericnode = AI_NUMERICHOST;
constexpr auto ai_numericserv = AI_NUMERICSERV;
#ifdef AI_ALL
constexpr auto ai_all = AI_ALL;
#else
constexpr auto ai_all = 0;
#endif
#ifdef AI_ADDRCONFIG
constexpr auto ai_addrconfig = AI_ADDRCONFIG;
#else
constexpr auto ai_addrconfig = 0;
#endif
#ifdef AI_V4MAPPED
constexpr auto ai_v4mapped = AI_V4MAPPED;
#else
constexpr auto ai_v4mapped = 0;
#endif

constexpr auto ni_numerichost = NI_NUMERICHOST;
constexpr auto ni_numericserv = NI_NUMERICSERV;

constexpr auto ni_maxhost = NI_MAXHOST;
constexpr auto ni_maxserv = NI_MAXSERV;

constexpr auto econnrefused = ECONNREFUSED;
constexpr auto etimedout = ETIMEDOUT;

inline int get_errno() { return errno; }

using ::getaddrinfo;
using ::freeaddrinfo;
using ::gai_strerror;

int connect_with_timeout(int fd, const sockaddr* address, socklen_t address_len, const std::chrono::milliseconds& timeout)
{
    const auto saved_flags = ::fcntl(fd, F_GETFL, 0);
    if(saved_flags < 0) return -1;
    if(::fcntl(fd, F_SETFL, saved_flags|O_NONBLOCK) < 0) return -1;

    const auto connect_error = ::connect(fd, address, address_len);
    const auto connect_errno = errno;

    if(::fcntl(fd, F_SETFL, saved_flags) < 0) return -1;

    if(connect_error == 0) return 0;
    if(connect_errno != EINPROGRESS) return -1;

    fd_set readfds{};
    FD_ZERO(&readfds);
    FD_SET(fd, &readfds);
    fd_set writefds{};
    FD_ZERO(&writefds);
    FD_SET(fd, &writefds);

    if(timeout.count())
    {
        timeval tv {
            static_cast<decltype(tv.tv_sec)>(timeout.count() / 1000),
            static_cast<decltype(tv.tv_usec)>(timeout.count() % 1000 * 1000)
        };
        auto error = ::select(FD_SETSIZE, &readfds, &writefds, nullptr, &tv);
        if(error == 0) { errno = ETIMEDOUT; return -1; }
        if(error < 0) return -1;
    }
    else
    {
        if(::select(FD_SETSIZE, &readfds, &writefds, nullptr, nullptr) < 0) return -1;
    }

    int result = 0;
    socklen_t result_len = static_cast<socklen_t>(sizeof result);
    if(::getsockopt(fd, SOL_SOCKET, SO_ERROR, &result, &result_len) < 0) return -1;

    if(result > 0) { errno = result; return -1; }
    return 0;
}

} // namespace net::posix
