export module net:http_server;
import :acceptor;
import :syslogstream;
import :http_headers;
import :endpointstream;
import :extension;
import std;

export namespace http {

using status = std::string;
using content = std::string;
using content_type = std::string;
using response = std::tuple<status, content>;
using response_with_headers = std::tuple<status, content, std::optional<headers>>;
using request_view = std::string_view;
using body_view = std::string_view;

class controller
{
public:

    using callback = std::function<::http::response(request_view, body_view, const headers&)>;

    void text(const content& c)
    {
        m_content_type = "text/plain";
        m_callback = [c](auto&&...) -> ::http::response { return {"200 OK", c}; };
    }

    void html(const content& c)
    {
        m_content_type = "text/html";
        m_callback = [c](auto&&...) -> ::http::response { return {"200 OK", c}; };
    }

    void css(const content& c)
    {
        m_content_type = "text/css";
        m_callback = [c](auto&&...) -> ::http::response { return {"200 OK", c}; };
    }

    void script(const content& c)
    {
        m_content_type = "application/javascript";
        m_callback = [c](auto&&...) -> ::http::response { return {"200 OK", c}; };
    }

    void json(const content& c)
    {
        m_content_type = "application/json";
        m_callback = [c](auto&&...) -> ::http::response { return {"200 OK", c}; };
    }

    void xml(const content& c)
    {
        m_content_type = "application/xml";
        m_callback = [c](auto&&...) -> ::http::response { return {"200 OK", c}; };
    }

    void response_handler(std::string_view ct, callback cb)
    {
        m_content_type = std::string{ct};
        m_callback = std::move(cb);
    }

    // Backwards compatible fluent API (used by YarDB)
    controller& response(std::string_view ct, callback cb)
    {
        response_handler(ct, std::move(cb));
        return *this;
    }

    using callback_with_headers = std::function<std::tuple<status, content, std::optional<headers>>(request_view, body_view, const headers&)>;

    void response_with_headers_handler(std::string_view ct, callback_with_headers cb)
    {
        m_content_type = std::string{ct};
        m_callback_with_headers = std::move(cb);
        m_has_custom_headers = true;
    }

    // Backwards compatible fluent API (used by YarDB)
    controller& response_with_headers(std::string_view ct, callback_with_headers cb)
    {
        response_with_headers_handler(ct, std::move(cb));
        return *this;
    }

    std::tuple<status, content, content_type, std::optional<headers>> render(request_view request, body_view body, const headers& h)
    {
        if(m_has_custom_headers && m_callback_with_headers)
        {
            auto [s, c, custom_h] = m_callback_with_headers(request, body, h);
            return std::make_tuple(std::move(s), std::move(c), m_content_type, std::move(custom_h));
        }
        else
        {
            auto [s, c] = m_callback(request, body, h);
            return std::make_tuple(std::move(s), std::move(c), m_content_type, std::nullopt);
        }
    }

private:

    content_type m_content_type = "*/*";
    callback m_callback = [](request_view, body_view, const headers&) -> ::http::response { return {"200 OK", "Not Found"}; };
    callback_with_headers m_callback_with_headers = nullptr;
    bool m_has_custom_headers = false;
};

class server
{
public:

    controller& get(const std::string& path)
    {
        m_methods.insert("GET");
        return m_router[path]["GET"];
    }

    controller& head(const std::string& path)
    {
        m_methods.insert("HEAD");
        return m_router[path]["HEAD"];
    }

    controller& post(const std::string& path)
    {
        m_methods.insert("POST");
        return m_router[path]["POST"];
    }

    controller& put(const std::string& path)
    {
        m_methods.insert("PUT");
        return m_router[path]["PUT"];
    }

    controller& patch(const std::string& path)
    {
        m_methods.insert("PATCH");
        return m_router[path]["PATCH"];
    }

    controller& destroy(const std::string& path)
    {
        m_methods.insert("DELETE");
        return m_router[path]["DELETE"];
    }

    void listen(std::string_view service_or_port = "http")
    {
        using namespace std::string_view_literals;
        m_stop.store(false);
        net::slog << net::notice("SERVER_START") << "starting up at " << service_or_port
                  << std::pair{"port"sv, service_or_port}
                  << net::flush;
        try
        {
            auto endpoint = net::acceptor{"0.0.0.0", service_or_port};
            auto check_timeout = m_timeout.count() ? m_timeout : std::chrono::seconds{1};
            endpoint.timeout(std::chrono::milliseconds{check_timeout.count() * 1000});
            net::slog << net::notice("SERVER_READY") << "started up at " << endpoint.host() << ":" << endpoint.service_or_port()
                      << std::pair{"addr", endpoint.host()}
                      << std::pair{"port", endpoint.service_or_port()}
                      << net::flush;
            
            while(!m_stop.load())
            {
                try
                {
                    net::slog << net::info("ACCEPT_WAIT") << "accepting connections" << net::flush;
                    auto client = endpoint.accept();
                    std::thread{[client_data = std::move(client), this]() mutable { handle(client_data); }}.detach();
                }
                catch(const std::system_error& e)
                {
                    if(std::string_view{e.what()}.contains("timeout"))
                    {
                        continue;
                    }
                    net::slog << net::error("ACCEPT_ERROR") << "failed to accept connection: " << e.what() << " (code: " << e.code() << ")"
                              << std::pair{"errno", e.code().value()}
                              << net::flush;
                    throw;
                }
                catch(const std::exception& e)
                {
                    net::slog << net::error("ACCEPT_EXCEPTION") << "exception while accepting connection: " << e.what() << net::flush;
                    throw;
                }
            }
            net::slog << net::notice("SERVER_STOP") << "server stopped" << net::flush;
        }
        catch(const std::system_error& e)
        {
            net::slog << net::error("LISTEN_ERROR") << "failed to create acceptor on " << service_or_port << ": " << e.what() << " (code: " << e.code() << ")"
                      << std::pair{"port"sv, service_or_port}
                      << std::pair{"errno", e.code().value()}
                      << net::flush;
            throw;
        }
        catch(const std::exception& e)
        {
            net::slog << net::error("LISTEN_EXCEPTION") << "exception during server startup on " << service_or_port << ": " << e.what()
                      << std::pair{"port"sv, service_or_port}
                      << net::flush;
            throw;
        }
    }

    void public_paths(std::string_view regex)
    {
        m_public_paths = std::string{regex};
    }

    void disable_public_paths()
    {
        m_public_paths = ""; // Empty regex matches nothing, requiring authentication
    }

    void credentials(std::initializer_list<std::string> tokens)
    {
        for (const auto& token : tokens) m_credentials.insert(token);
    }

    const auto& timeout() const
    {
        return m_timeout;
    }

    void timeout(const std::chrono::seconds& t)
    {
        m_timeout = t;
    }

    void stop()
    {
        m_stop.store(true);
    }

    bool stopped() const
    {
        return m_stop.load();
    }

private:

    auto date() const
    {
        // Prefer C++23 chrono formatting where it is stable.
        // clang-22 (macOS) is known to crash compiling chrono formatting via std::format/std::vformat in our modules setup.
        // Keep local dev stable while still enabling CI coverage on Linux.
#if defined(__APPLE__) && defined(__clang__) && (__clang_major__ >= 22)
        return extension::rfc1123_legacy(std::chrono::system_clock::now());
#else
        using namespace std::chrono;
        const auto tp = floor<seconds>(std::chrono::system_clock::now());
        return std::vformat("{:%a, %d %b %Y %H:%M:%S GMT}", std::make_format_args(tp));
#endif
    }

    const auto& host() const
    {
        static auto s_host = net::syslog::gethostname();
        return s_host;
    }

    auto methods() const
    {
        std::string tmp = "";
        for(const auto&  m : m_methods)
        {
            if(!tmp.empty()) tmp += ", ";
            tmp += m;
        }
        return tmp;
    }

    void handle(auto& client)
    {
        using namespace std::string_view_literals;
        using namespace std::chrono;
        auto& [stream, endpoint, port] = client;
        const auto conn_start = system_clock::now();
        net::slog << net::notice("CONN_ACCEPT") << "accepted connection from " << endpoint << ":" << port
                  << std::pair{"ip"sv, endpoint}
                  << std::pair{"port", port}
                  << net::flush;

        try
        {
            while(stream)
            {
                std::string method, uri, version;
                stream >> method >> uri >> version >> net::crlf;

                if(!stream.good())
                {
                    if(stream.eof())
                    {
                        const auto conn_duration = duration_cast<milliseconds>(system_clock::now() - conn_start).count();
                        net::slog << net::info("CONN_CLOSED") << "connection closed by client " << endpoint << ":" << port
                                  << std::pair{"ip"sv, endpoint}
                                  << std::pair{"port", port}
                                  << std::pair{"connection_duration_ms", conn_duration}
                                  << net::flush;
                    }
                    else
                    {
                        const auto conn_duration = duration_cast<milliseconds>(system_clock::now() - conn_start).count();
                        net::slog << net::warning("STREAM_ERROR") << "stream error reading request from " << endpoint << ":" << port << " (eof: " << stream.eof() << ", fail: " << stream.fail() << ", bad: " << stream.bad() << ")"
                                  << std::pair{"ip"sv, endpoint}
                                  << std::pair{"port", port}
                                  << std::pair{"eof", stream.eof()}
                                  << std::pair{"fail", stream.fail()}
                                  << std::pair{"bad", stream.bad()}
                                  << std::pair{"connection_duration_ms", conn_duration}
                                  << net::flush;
                    }
                    break;
                }

                // Generate request ID for correlation
                static std::atomic<std::uint64_t> request_counter{0};
                const auto request_id = std::to_string(++request_counter);
                const auto request_start = system_clock::now();

                net::slog << net::notice("HTTP_REQUEST") << "request \"" << method << ' ' << uri << ' ' << version << "\""
                          << std::pair{"ip"sv, endpoint}
                          << std::pair{"port", port}
                          << std::pair{"method", method}
                          << std::pair{"uri", std::string{uri}}
                          << std::pair{"version", version}
                          << std::pair{"request_id", request_id}
                          << net::flush;

                headers hs{};
                try
                {
                    stream >> hs >> net::crlf;
                }
                catch(const std::exception& e)
                {
                    const auto request_duration = duration_cast<milliseconds>(system_clock::now() - request_start).count();
                    net::slog << net::error("PARSE_HEADERS_ERROR") << "failed to parse headers from " << endpoint << ":" << port << ": " << e.what()
                              << std::pair{"ip"sv, endpoint}
                              << std::pair{"port", port}
                              << std::pair{"status", 400}
                              << std::pair{"request_id", request_id}
                              << std::pair{"duration_ms", request_duration}
                              << net::flush;
                    stream << "HTTP/1.0 400 Bad Request" << net::crlf
                           << "Date: " << date() << net::crlf
                           << "Server: " << host() << net::crlf
                           << "Content-Type: " << m_content_type << net::crlf
                           << "Content-Length: 0" << net::crlf
                           << net::crlf << net::flush;
                    break;
                }

                std::string origin = "*";
                if(hs.contains("origin"))
                    origin = hs["origin"];

                std::string authorization = "";
                if(hs.contains("authorization"))
                    authorization = hs["authorization"];

                // Extract additional headers for logging
                std::string user_agent = "";
                if(hs.contains("user-agent"))
                    user_agent = hs["user-agent"];

                std::string content_type = "";
                if(hs.contains("content-type"))
                    content_type = hs["content-type"];

                std::string accept = "";
                if(hs.contains("accept"))
                    accept = hs["accept"];

                // Log additional headers if present
                if(!user_agent.empty() || !content_type.empty() || !accept.empty())
                {
                    net::slog << net::debug("HTTP_REQUEST_HEADERS") << "request headers"
                              << std::pair{"ip"sv, endpoint}
                              << std::pair{"port", port}
                              << std::pair{"request_id", request_id}
                              << std::pair{"user_agent", user_agent}
                              << std::pair{"content_type", content_type}
                              << std::pair{"accept", accept}
                              << net::flush;
                }

                long long content_length = 0;
                if(hs.contains("content-length"))
                {
                    try
                    {
                        content_length = std::stoll(hs["content-length"]);
                        if(content_length < 0)
                        {
                            net::slog << net::warning("INVALID_CONTENT_LENGTH") << "negative content-length from " << endpoint << ":" << port
                                      << std::pair{"ip"sv, endpoint}
                                      << std::pair{"port", port}
                                      << std::pair{"content_length", content_length}
                                      << net::flush;
                            content_length = 0;
                        }
                    }
                    catch(const std::invalid_argument&)
                    {
                        net::slog << net::warning("INVALID_CONTENT_LENGTH") << "invalid content-length format \"" << hs["content-length"] << "\" from " << endpoint << ":" << port
                                  << std::pair{"ip"sv, endpoint}
                                  << std::pair{"port", port}
                                  << std::pair{"content_length_str", hs["content-length"]}
                                  << net::flush;
                        content_length = 0;
                    }
                    catch(const std::out_of_range&)
                    {
                        net::slog << net::warning("INVALID_CONTENT_LENGTH") << "content-length out of range \"" << hs["content-length"] << "\" from " << endpoint << ":" << port
                                  << std::pair{"ip"sv, endpoint}
                                  << std::pair{"port", port}
                                  << std::pair{"content_length_str", hs["content-length"]}
                                  << net::flush;
                        content_length = 0;
                    }
                    catch(const std::exception& e)
                    {
                        net::slog << net::warning("INVALID_CONTENT_LENGTH") << "error parsing content-length \"" << hs["content-length"] << "\" from " << endpoint << ":" << port << ": " << e.what()
                                  << std::pair{"ip"sv, endpoint}
                                  << std::pair{"port", port}
                                  << std::pair{"content_length_str", hs["content-length"]}
                                  << net::flush;
                        content_length = 0;
                    }
                }

                std::string body(static_cast<std::size_t>(content_length), ' ');
                try
                {
                    for(auto& c : body)
                    {
                        auto ch = stream.get();
                        if(stream.eof() || stream.fail())
                        {
                            net::slog << net::warning("INCOMPLETE_BODY") << "incomplete body read from " << endpoint << ":" << port << " (expected " << content_length << " bytes)"
                                      << std::pair{"ip"sv, endpoint}
                                      << std::pair{"port", port}
                                      << std::pair{"expected_bytes", static_cast<long long>(content_length)}
                                      << net::flush;
                            break;
                        }
                        c = static_cast<char>(ch);
                    }
                }
                catch(const std::exception& e)
                {
                    net::slog << net::error("BODY_READ_ERROR") << "error reading body from " << endpoint << ":" << port << ": " << e.what()
                              << std::pair{"ip"sv, endpoint}
                              << std::pair{"port", port}
                              << net::flush;
                }

                net::slog << net::debug("REQUEST_BODY") << "request body \"" << body << "\""
                          << std::pair{"ip"sv, endpoint}
                          << std::pair{"port", port}
                          << std::pair{"body_size", static_cast<long long>(body.size())}
                          << net::flush;

                if(version != "HTTP/1.1")
                {
                    const auto request_duration = duration_cast<milliseconds>(system_clock::now() - request_start).count();
                    net::slog << net::warning("UNSUPPORTED_VERSION") << "unsupported HTTP version \"" << version << "\" from " << endpoint << ":" << port
                              << std::pair{"ip"sv, endpoint}
                              << std::pair{"port", port}
                              << std::pair{"method", method}
                              << std::pair{"uri", std::string{uri}}
                              << std::pair{"version", version}
                              << std::pair{"status", 505}
                              << std::pair{"request_id", request_id}
                              << std::pair{"duration_ms", request_duration}
                              << net::flush;
                    stream << "HTTP/1.1 505 HTTP Version Not Supported" << net::crlf
                           << "Date: "         << date()                << net::crlf
                           << "Server: "       << host()                << net::crlf
                           << "Content-Type: " << m_content_type        << net::crlf
                           << "Content-Length: 0"                       << net::crlf
                           << net::crlf << net::flush;
                }
                else if(!m_methods.contains(method))
                {
                    const auto request_duration = duration_cast<milliseconds>(system_clock::now() - request_start).count();
                    net::slog << net::warning("UNSUPPORTED_METHOD") << "unsupported HTTP method \"" << method << "\" for \"" << uri << "\" from " << endpoint << ":" << port
                              << std::pair{"ip"sv, endpoint}
                              << std::pair{"port", port}
                              << std::pair{"method", method}
                              << std::pair{"uri", std::string{uri}}
                              << std::pair{"status", 400}
                              << std::pair{"request_id", request_id}
                              << std::pair{"duration_ms", request_duration}
                              << net::flush;
                    stream << "HTTP/1.1 400 Bad Request"                    << net::crlf
                           << "Date: "         << date()                    << net::crlf
                           << "Server: "       << host()                    << net::crlf
                           << "Content-Type: " << m_content_type            << net::crlf
                           << "Content-Length: 0"                           << net::crlf
                           << "Access-Control-Allow-Methods: " << methods() << net::crlf
                           << net::crlf << net::flush;
                }
                else if(uri == "/favicon.ico")
                {
                    const auto request_duration = duration_cast<milliseconds>(system_clock::now() - request_start).count();
                    net::slog << net::debug("FAVICON_REQUEST") << "favicon request from " << endpoint << ":" << port
                              << std::pair{"ip"sv, endpoint}
                              << std::pair{"port", port}
                              << std::pair{"method", method}
                              << std::pair{"uri", std::string{uri}}
                              << std::pair{"status", 404}
                              << std::pair{"request_id", request_id}
                              << std::pair{"duration_ms", request_duration}
                              << net::flush;
                    stream << "HTTP/1.1 404 Not Found"           << net::crlf
                           << "Date: "         << date()         << net::crlf
                           << "Server: "       << host()         << net::crlf
                           << "Content-Type: " << m_content_type << net::crlf
                           << "Content-Length: 0"                << net::crlf
                           << net::crlf << net::flush;
                }
                else if(!std::regex_match(std::string{uri}, std::regex(m_public_paths)) && !m_credentials.contains(authorization))
                {
                    const auto request_duration = duration_cast<milliseconds>(system_clock::now() - request_start).count();
                    net::slog << net::warning("UNAUTHORIZED") << "unauthorized request for \"" << uri << "\" from " << endpoint << ":" << port
                              << std::pair{"ip"sv, endpoint}
                              << std::pair{"port", port}
                              << std::pair{"method", method}
                              << std::pair{"uri", std::string{uri}}
                              << std::pair{"status", 401}
                              << std::pair{"request_id", request_id}
                              << std::pair{"duration_ms", request_duration}
                              << net::flush;
                    stream << "HTTP/1.1 401 Unauthorized status"                     << net::crlf
                           << "Date: "         << date()                             << net::crlf
                           << "Server: "       << host()                             << net::crlf
                           << "Content-Type: " << m_content_type                     << net::crlf
                           << "Content-Length: 0"                                    << net::crlf
                           << "WWW-Authenticate: Basic realm=\"User Visible Realm\"" << net::crlf
                           << net::crlf << net::flush;
                }
                else
                {
                    std::string res_status, res_type, res_content;
                    std::optional<headers> custom_headers;

                    for(auto& [path, methods_map] : m_router)
                        if(std::regex_match(std::string{uri}, std::regex(path)))
                        {
                            auto it = methods_map.find(method);
                            // If HEAD method not found, try GET as fallback for HEAD requests
                            if(it == methods_map.end() && method == "HEAD")
                                it = methods_map.find("GET");

                            if(it != methods_map.end())
                            {
                                try
                                {
                                    std::tie(res_status, res_content, res_type, custom_headers) = it->second.render(uri, body, hs);
                                    if(!res_type.empty())
                                        break;
                                }
                                catch(const std::exception& e)
                                {
                                    const auto request_duration = duration_cast<milliseconds>(system_clock::now() - request_start).count();
                                    net::slog << net::error("HANDLER_EXCEPTION") << "exception in handler for \"" << method << " " << uri << "\" (route: " << path << "): " << e.what()
                                              << std::pair{"ip"sv, endpoint}
                                              << std::pair{"port", port}
                                              << std::pair{"method", method}
                                              << std::pair{"uri", std::string{uri}}
                                              << std::pair{"route", path}
                                              << std::pair{"status", 500}
                                              << std::pair{"request_id", request_id}
                                              << std::pair{"duration_ms", request_duration}
                                              << net::flush;
                                    res_status = "500 Internal Server Error";
                                    res_content = "";
                                    res_type = m_content_type;
                                    custom_headers = std::nullopt;
                                    break;
                                }
                            }
                        }

                    if(!res_type.empty())
                    {
                        // Extract status code from status string (e.g., "200 OK" -> 200)
                        auto status_code = 200ll;
                        try {
                            if(auto space_pos = res_status.find(' '); space_pos != std::string::npos) {
                                status_code = std::stoll(res_status.substr(0, space_pos));
                            }
                        } catch(...) {}
                        
                        // Calculate request duration
                        const auto request_duration = duration_cast<milliseconds>(system_clock::now() - request_start).count();
                        
                        net::slog << net::info("HTTP_RESPONSE") << "response " << res_status
                                  << std::pair{"ip"sv, endpoint}
                                  << std::pair{"port", port}
                                  << std::pair{"method", method}
                                  << std::pair{"uri", std::string{uri}}
                                  << std::pair{"status", status_code}
                                  << std::pair{"content_length", static_cast<long long>(res_content.length())}
                                  << std::pair{"request_id", request_id}
                                  << std::pair{"duration_ms", request_duration}
                                  << net::flush;
                        
                        stream << "HTTP/1.1 " << res_status                                   << net::crlf
                               << "Date: " << date()                                          << net::crlf
                               << "Server: " << host()                                        << net::crlf
                               << "Content-Type: " << res_type                                << net::crlf
                               << "Content-Length: " << res_content.length()                  << net::crlf;
                        
                        if(custom_headers.has_value())
                            stream << custom_headers.value();
                        
                        stream << "Access-Control-Allow-Methods: " << methods()               << net::crlf
                               << "Cache-Control: private"                                    << net::crlf
                               << "Access-Control-Allow-Origin: " << origin                   << net::crlf
                               << "Access-Control-Allow-Headers: Content-Type, Authorization" << net::crlf
                               << "Access-Control-Allow-Credentials: true"                    << net::crlf
                               << net::crlf
                               << (method != "HEAD" ? res_content : "") << net::flush;
                    }
                    else
                    {
                            // Calculate request duration for 404
                        const auto request_duration = duration_cast<milliseconds>(system_clock::now() - request_start).count();
                        
                        net::slog << net::warning("ROUTE_NOT_FOUND") << "no route found for \"" << method << " " << uri << "\" from " << endpoint << ":" << port
                                  << std::pair{"ip"sv, endpoint}
                                  << std::pair{"port", port}
                                  << std::pair{"method", method}
                                  << std::pair{"uri", std::string{uri}}
                                  << std::pair{"status", 404}
                                  << std::pair{"request_id", request_id}
                                  << std::pair{"duration_ms", request_duration}
                                  << net::flush;
                        stream << "HTTP/1.0 404 Not Found"                                    << net::crlf
                               << "Date: " << date()                                          << net::crlf
                               << "Server: " << host()                                        << net::crlf
                               << "Content-Type: " << m_content_type                          << net::crlf
                               << "Content-Length: 0"                                         << net::crlf
                               << "Access-Control-Allow-Methods: " << methods()               << net::crlf
                               << "Cache-Control: private"                                    << net::crlf
                               << "Access-Control-Allow-Origin: " << origin                   << net::crlf
                               << "Access-Control-Allow-Headers: Content-Type, Authorization" << net::crlf
                               << "Access-Control-Allow-Credentials: true"                    << net::crlf
                               << net::crlf << net::flush;
                    }
                }
            }
            const auto conn_duration = duration_cast<milliseconds>(system_clock::now() - conn_start).count();
            net::slog << net::info("CONN_CLOSED") << "connection closed"
                              << std::pair{"ip"sv, endpoint}
                      << std::pair{"port", port}
                      << std::pair{"connection_duration_ms", conn_duration}
                      << net::flush;
        }
        catch(const std::system_error& e)
        {
            net::slog << net::error("SYSTEM_ERROR") << "system error handling connection from " << endpoint << ":" << port << ": " << e.what() << " (code: " << e.code() << ")"
                              << std::pair{"ip"sv, endpoint}
                      << std::pair{"port", port}
                      << std::pair{"errno", e.code().value()}
                      << std::pair{"status", 500}
                      << net::flush;
            try
            {
                stream << "HTTP/1.0 500 Internal Server Error" << net::crlf
                       << "Date: " << date()                   << net::crlf
                       << "Server: " << host()                 << net::crlf
                       << "Content-Type: " << m_content_type   << net::crlf
                       << "Content-Length: 0"                  << net::crlf
                       << net::crlf << net::flush;
            }
            catch(const std::exception& write_error)
            {
                net::slog << net::error("WRITE_ERROR") << "failed to write error response to " << endpoint << ":" << port << ": " << write_error.what()
                          << std::pair{"ip"sv, endpoint}
                          << std::pair{"port", port}
                          << net::flush;
            }
        }
        catch(const std::exception& e)
        {
            net::slog << net::error("CONN_EXCEPTION") << "exception handling connection from " << endpoint << ":" << port << ": " << e.what()
                              << std::pair{"ip"sv, endpoint}
                      << std::pair{"port", port}
                      << std::pair{"status", 500}
                      << net::flush;
            try
            {
                stream << "HTTP/1.0 500 Internal Server Error" << net::crlf
                       << "Date: " << date()                   << net::crlf
                       << "Server: " << host()                 << net::crlf
                       << "Content-Type: " << m_content_type   << net::crlf
                       << "Content-Length: 0"                  << net::crlf
                       << net::crlf << net::flush;
            }
            catch(const std::exception& write_error)
            {
                net::slog << net::error("WRITE_ERROR") << "failed to write error response to " << endpoint << ":" << port << ": " << write_error.what()
                          << std::pair{"ip"sv, endpoint}
                          << std::pair{"port", port}
                          << net::flush;
            }
        }
        catch(...)
        {
            net::slog << net::error("UNKNOWN_EXCEPTION") << "unknown exception (non-standard exception type) handling connection from " << endpoint << ":" << port
                              << std::pair{"ip"sv, endpoint}
                      << std::pair{"port", port}
                      << std::pair{"status", 500}
                      << net::flush;
            try
            {
                stream << "HTTP/1.0 500 Internal Server Error" << net::crlf
                       << "Date: " << date()                   << net::crlf
                       << "Server: " << host()                 << net::crlf
                       << "Content-Type: " << m_content_type   << net::crlf
                       << "Content-Length: 0"                  << net::crlf
                       << net::crlf << net::flush;
            }
            catch(const std::exception& write_error)
            {
                net::slog << net::error("WRITE_ERROR") << "failed to write error response to " << endpoint << ":" << port << ": " << write_error.what()
                          << std::pair{"ip"sv, endpoint}
                          << std::pair{"port", port}
                          << net::flush;
            }
            catch(...)
            {
                net::slog << net::error("WRITE_ERROR") << "failed to write error response to " << endpoint << ":" << port << " (unknown exception in write)"
                          << std::pair{"ip"sv, endpoint}
                          << std::pair{"port", port}
                          << net::flush;
            }
        }
    }

    using router_type = std::map<std::string, std::map<std::string, controller>, std::less<>>;
    router_type m_router = {};
    std::string m_content_type = "*/*";
    std::set<std::string> m_methods = {"HEAD", "OPTIONS"};
    std::string m_public_paths = ".*";
    std::set<std::string> m_credentials = {};
    std::chrono::seconds m_timeout = std::chrono::seconds{0};
    std::atomic<bool> m_stop{false};
};

template <typename... Args>
auto make_response(Args&&... args) -> decltype(std::make_pair(std::forward<Args>(args)...))
{
    return std::make_pair(std::forward<Args>(args)...);
}

} // namespace http

