export module net:uri;
import std;

export namespace net {

class uri
{
public:
    template<typename T>
    class property
    {
    public:
        operator T () const { return m_value; }
        auto operator == (const T& value) const { return m_value == value; }
    protected:
        T m_value;
    private:
        friend class uri;
        auto& operator = (T&& value) { m_value = std::move(value); return *this; }
    };

    template <char delim>
    class indexed_property : public property<std::string_view>
    {
    public:
        auto operator [] (std::size_t idx) const { return (idx < m_index.size()) ? m_index[idx] : std::string_view{}; }
        auto begin() const { return m_index.cbegin(); }
        auto end() const { return m_index.cend(); }
    private:
        friend class uri;
        auto& operator = (std::string_view value)
        {
            this->m_value = value;
            auto pos = value.find_first_of(delim);
            while(pos != std::string_view::npos)
            {
                m_index.emplace_back(value.substr(0, pos));
                value.remove_prefix(pos + 1);
                pos = value.find_first_of(delim);
            }
            m_index.emplace_back(value.substr());
            return *this;
        }
        std::vector<std::string_view> m_index;
    };

    uri(std::string_view string)
    {
        absolute = false;
        auto position = string.find_first_of(":@[]/?#");
        if(position != std::string_view::npos && string.at(position) == ':')
        {
            absolute = true;
            scheme = string.substr(0, position);
            string.remove_prefix(position + 1);
        }

        position = string.find_first_not_of("/");
        if(position == 2)
        {
            string.remove_prefix(2);
            position = string.find_first_of("/?#");
            auto authority = string.substr(0, position);
            string.remove_prefix(position);

            position = authority.find_first_of('@');
            if(position != std::string_view::npos)
            {
                userinfo = authority.substr(0, position);
                authority.remove_prefix(position + 1);
            }

            position = authority.find_last_of(':');
            if(position != std::string_view::npos)
            {
                const auto size = authority.length() - position;
                port = authority.substr(position + 1, size - 1);
                authority.remove_suffix(size);
            }
            host = authority.substr();
        }

        position = string.find_first_of("?#");
        path = string.substr(0, position);
        string.remove_prefix(position);

        if(!string.empty() && string.front() == '?')
        {
            string.remove_prefix(1);
            position = string.find_first_of("#");
            query = string.substr(0, position);
            string.remove_prefix(position);
        }

        if(!string.empty() && string.front() == '#')
        {
            string.remove_prefix(1);
            fragment = string.substr();
        }
    }

    property<bool> absolute;
    property<std::string_view> scheme;
    property<std::string_view> userinfo;
    property<std::string_view> host;
    property<std::string_view> port;
    indexed_property<'/'> path;
    indexed_property<'&'> query;
    property<std::string_view> fragment;
};

template<typename T>
inline auto& operator << (std::ostream& os, const uri::property<T>& p)
{
    os << static_cast<const T&>(p);
    return os;
}

// URL decode a string (percent-encoding: %20 -> space, %25 -> %, etc.)
inline auto url_decode(std::string_view encoded)
{
    auto decoded = std::string{};
    decoded.reserve(encoded.size());
    
    for(std::size_t i = 0; i < encoded.size(); ++i)
    {
        if(encoded[i] == '%' && i + 2 < encoded.size())
        {
            // Try to decode hex pair
            auto hex_str = encoded.substr(i + 1, 2);
            auto value = 0;
            auto [ptr, ec] = std::from_chars(hex_str.data(), hex_str.data() + hex_str.size(), value, 16);
            if(ec == std::errc{} && ptr == hex_str.data() + hex_str.size())
            {
                decoded += static_cast<char>(value);
                i += 2; // Skip the two hex digits
                continue;
            }
        }
        // Not a valid %XX sequence, or + (which should be space in query strings)
        if(encoded[i] == '+')
        {
            decoded += ' ';
        }
        else
        {
            decoded += encoded[i];
        }
    }
    
    return decoded;
}

} // namespace net

